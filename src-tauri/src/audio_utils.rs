use anyhow::{Context, Result, anyhow};
use audioadapter_buffers::owned::SequentialOwned;
use rubato::{
    Async, FixedAsync, Resampler, SincInterpolationParameters, SincInterpolationType,
    WindowFunction,
};

pub fn read_and_resample(path: &str) -> Result<Vec<f32>> {
    let mut reader = hound::WavReader::open(path).context("Failed to open WAV file")?;
    let spec = reader.spec();

    let channels = spec.channels as usize;
    let source_sample_rate = spec.sample_rate as usize;
    let target_sample_rate = 16000;

    // Read all samples
    // We assume the input is Float 32-bit as generated by our recorder.
    // If we want to support other formats, we need to handle them here.
    let samples: Vec<f32> = match spec.sample_format {
        hound::SampleFormat::Float => reader.samples::<f32>().collect::<Result<Vec<_>, _>>()?,
        hound::SampleFormat::Int => {
            // Fallback for Int formats if needed, though we write Float
            let max_val = if spec.bits_per_sample == 16 {
                i16::MAX as f32
            } else {
                i32::MAX as f32
            };
            reader
                .samples::<i32>()
                .map(|s| s.map(|x| x as f32 / max_val))
                .collect::<Result<Vec<_>, _>>()?
        }
    };

    // Convert to Mono
    let mut mono_samples = Vec::with_capacity(samples.len() / channels);
    if channels == 1 {
        mono_samples = samples;
    } else {
        for chunk in samples.chunks(channels) {
            let sum: f32 = chunk.iter().sum();
            mono_samples.push(sum / channels as f32);
        }
    }

    if source_sample_rate == target_sample_rate {
        return Ok(mono_samples);
    }

    // Resample using rubato 1.0 API
    let params = SincInterpolationParameters {
        sinc_len: 256,
        f_cutoff: 0.95,
        interpolation: SincInterpolationType::Linear,
        oversampling_factor: 256,
        window: WindowFunction::BlackmanHarris2,
    };

    let resample_ratio = target_sample_rate as f64 / source_sample_rate as f64;
    let input_frames = mono_samples.len();

    let mut resampler = Async::<f32>::new_sinc(
        resample_ratio,
        2.0,
        &params,
        input_frames,
        1,
        FixedAsync::Input,
    )
    .map_err(|e| anyhow!("Failed to create resampler: {}", e))?;

    // Prepare input data using SequentialOwned (1 channel, input_frames frames)
    let input_adapter = SequentialOwned::new_from(mono_samples, 1, input_frames)
        .map_err(|e| anyhow!("Failed to create input adapter: {:?}", e))?;

    // Prepare output buffer
    let output_frames = (input_frames as f64 * resample_ratio * 1.1) as usize + 1024;
    let output_data = vec![0.0f32; output_frames];
    let mut output_adapter = SequentialOwned::new_from(output_data, 1, output_frames)
        .map_err(|e| anyhow!("Failed to create output adapter: {:?}", e))?;

    // Process all input (4 arguments: input, output, chunk_size, indexing)
    let (_frames_read, frames_written) = resampler
        .process_all_into_buffer(&input_adapter, &mut output_adapter, input_frames, None)
        .map_err(|e| anyhow!("Resampling failed: {}", e))?;

    // Extract resampled data
    let output_data = output_adapter.take_data();
    let resampled = output_data[..frames_written].to_vec();
    Ok(resampled)
}
