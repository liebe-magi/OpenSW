use anyhow::{anyhow, Context, Result};
use rubato::{
    Resampler, SincFixedIn, SincInterpolationParameters, SincInterpolationType, WindowFunction,
};

pub fn read_and_resample(path: &str) -> Result<Vec<f32>> {
    let mut reader = hound::WavReader::open(path).context("Failed to open WAV file")?;
    let spec = reader.spec();

    let channels = spec.channels as usize;
    let source_sample_rate = spec.sample_rate as usize;
    let target_sample_rate = 16000;

    // Read all samples
    // We assume the input is Float 32-bit as generated by our recorder.
    // If we want to support other formats, we need to handle them here.
    let samples: Vec<f32> = match spec.sample_format {
        hound::SampleFormat::Float => reader.samples::<f32>().collect::<Result<Vec<_>, _>>()?,
        hound::SampleFormat::Int => {
            // Fallback for Int formats if needed, though we write Float
            let max_val = if spec.bits_per_sample == 16 {
                i16::MAX as f32
            } else {
                i32::MAX as f32
            };
            reader
                .samples::<i32>()
                .map(|s| s.map(|x| x as f32 / max_val))
                .collect::<Result<Vec<_>, _>>()?
        }
    };

    // Convert to Mono
    let mut mono_samples = Vec::with_capacity(samples.len() / channels);
    if channels == 1 {
        mono_samples = samples;
    } else {
        for chunk in samples.chunks(channels) {
            let sum: f32 = chunk.iter().sum();
            mono_samples.push(sum / channels as f32);
        }
    }

    if source_sample_rate == target_sample_rate {
        return Ok(mono_samples);
    }

    // Resample
    let params = SincInterpolationParameters {
        sinc_len: 256,
        f_cutoff: 0.95,
        interpolation: SincInterpolationType::Linear,
        oversampling_factor: 256,
        window: WindowFunction::BlackmanHarris2,
    };

    let resample_ratio = target_sample_rate as f64 / source_sample_rate as f64;

    let mut resampler = SincFixedIn::<f32>::new(resample_ratio, 2.0, params, mono_samples.len(), 1)
        .map_err(|e| anyhow!("Failed to create resampler: {}", e))?;

    let waves_in = vec![mono_samples];
    let waves_out = resampler
        .process(&waves_in, None)
        .map_err(|e| anyhow!("Resampling failed: {}", e))?;

    Ok(waves_out[0].clone())
}
